# Bashido 
# Copyright Â© 2015-2016 Vladimir Zorin
# Licensed under GPLv3, see the full license in 
# the LICENSE file in root folder of the project

CERT_SUBJ_FIELDS=${CERT_SUBJ_FIELDS:-''}

cert.self_signed () {
<<SELFDOC
# USAGE:
#   cert.self_signed [commonName] [keyLength] [days]
#
# DESCRIPTION:
#   Generates a self signed certificate, valid for days days with a RSA key,
#   which length is equal to keyLength.
#
#   If commonName is provided, produced certificate will be saved into 
#   commonName.crt file, and the key into commonName.key. The common name
#   field of the certificate will also be set to commonName. 
#
# DEFAULT VALUES:
#   commonName: cert
#   keyLength: 2048
#   days: 3650  
#
SELFDOC

    if bashido.check_args_count 0 "$@"; then bashido.show_doc ${FUNCNAME}; return 1; fi

    local commonName=${1:-cert}; shift
    local keyLength=${1:-2048}; shift
    local days=${1:-3650}; shift
    local subjFields="${CERT_SUBJ_FIELDS}/CN=${commonName}/"
    openssl req -newkey rsa:${keyLength} \
                -keyout ${commonName}.key -days ${days} \
                -x509 -sha256 -nodes -extensions v3_ca -out ${commonName}.crt \
                -subj "${subjFields}"

}

cert.request () {
<<SELFDOC
# USAGE:
#   cert.request commonName [keyLength]
#
# DESCRIPTION:
#   Generates a certificate request (with common name set to commonName) 
#   and a new key of keyLength.
#   Outputs the request into commonName.csr and the key into commonName.key.
#   If keyLength is not provided, it defaults to 2048. 
#  
#   Upon generating the request this function will use subjectAltName 
#   extension, and the only SAN will be set to www.commonName.
#   If you want to provide more SANs, you can do so via the environment 
#   variable SANS:
#     SANS="DNS:sub1.commonName,DNS:sub2.commonName" cert.request commonName
#
#   cert.sign function will get SANS from csr upon signing, however, keep in
#   mind that when signing requests manually you should provide desired SANs
#   yourself.
SELFDOC
    
    local commonName=${1}; shift
    local keyLength=${1:-2048}; shift
    local subjFields="${CERT_SUBJ_FIELDS}/CN=${commonName}"

    SANS=${SANS:-"DNS:www.${commonName}"} openssl req -config certAuth/req.cnf \
                -newkey rsa:2048 -nodes -out ${commonName}.csr -keyout ${commonName}.key \
                -subj "${subjFields}"
}

cert.sign () {
<<SELFDOC
# USAGE:
#   cert.sign certRequest.csr
# 
# DESCRIPTION:
#   Signs the certRequest.csr with the root certificate which was
#   generated by the cert.init function. 
#   
#   Generated certificate will have the name certRequest.crt
SELFDOC

    local csrFile=${1}; shift
    local outFile=${csrFile%.csr}.crt
    
    SANS=$(cert.rinspect ${csrFile} 2>&1|grep DNS) openssl ca -batch -notext -config certAuth/ca.cnf -name certAuth -in ${csrFile} -out ${outFile} -extensions v3_req -extfile certAuth/req.cnf

}

cert.inspect () {
<<SELFDOC
# USAGE:
#   cert.inspect certName
#
# DESCRIPTION:
#   Outputs information about certName certificate in plain text format
SELFDOC
    
    local certName="${1}"; shift
    openssl x509 -text -noout -in "${certName}"
}

cert.req_inspect () {
<<SELFDOC
# USAGE:
#   cert.req_inspect certRequest
#
# DESCRIPTION:
#   Outputs information about certificate request certRequest.csr in plain text format
SELFDOC
    local certRequest="${1}"; shift 
    openssl req -text -verify -noout -in "${certRequest}"
}

cert.trust () {
<<SELFDOC
# USAGE:
#   cert.trust certName.crt
#
# DESCRIPTION:
#   Copies certName.crt to /usr/local/share/ca-certificates/ and 
#   launches update-ca-certificates after that. This operation
#   should make certName.crt "trusted" by your system. Well,   
#   at least curl will stop whining. 
#
#   Unfortunately, this does not affect firefox, so the function
#   will check if you have firefox binary in your path and
#   certutil tool (found in libnss3-tools package). If that's
#   the case, certName.crt will also be added to firefox's
#   trusted certificates storage.
SELFDOC

    local certName="${1}"; shift

    sudo cp ${certName} /usr/local/share/ca-certificates/
    sudo update-ca-certificates

# Now, as for the firefox, there are, of course, no easy ways :)
# (based on this stack overflow entry: https://stackoverflow.com/a/2760345)
    if (which firefox > /dev/null) && (which certutil > /dev/null); then 

        local certificateFile="${certName}"
        local certificateName="${certName%.crt}" 

        for certDB in $(find  ~/.mozilla* ~/.thunderbird -name "cert8.db")
        do
          certDir=$(dirname ${certDB});
          #log "mozilla certificate" "install '${certificateName}' in ${certDir}"
          certutil -A -n "${certificateName}" -t "TCu,Cuw,Tuw" -i ${certificateFile} -d ${certDir}
        done
    fi

}

cert.init_CA () {
    
    mkdir -p certAuth/newcerts
    touch    certAuth/index.txt
    echo "01" > certAuth/serial

cat <<EOF > certAuth/ca.cnf
[ certAuth ]

dir             = ./certAuth            # Where everything is kept
certs           = \$dir/certs            # Where the issued certs are kept
database        = \$dir/index.txt        # database index file.
new_certs_dir   = \$dir/newcerts         # default place for new certs.
serial          = \$dir/serial           # The current serial number
certificate     = \$dir/CA.crt
private_key     = \$dir/CA.key

name_opt        = ca_default            # Subject Name options
cert_opt        = ca_default            # Certificate field options

default_days    = 365                   # how long to certify for
default_crl_days= 30                    # how long before next CRL
default_md      = default               # use public key default MD
preserve        = no                    # keep passed DN ordering
policy          = policy_anything

[ policy_anything ]
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
EOF

cat <<EOF > certAuth/req.cnf
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req

[req_distinguished_name]
countryName = Country Name (2 letter code)
countryName_default = UA
stateOrProvinceName = State or Province Name (full name)
stateOrProvinceName_default = Kyiv
localityName = Locality Name (eg, city)
localityName_default = Kyiv
organizationalUnitName  = Organizational Unit Name (eg, section)
organizationalUnitName_default  = CA
commonName = common name, mate
commonName_max  = 64

[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName=\$ENV::SANS
EOF

cert.self_signed master
mv master.crt certAuth/CA.crt
mv master.key certAuth/CA.key

}
